/*
 **********************
 * general item funcs *
 **********************
 */

// Return a list of keys in an object that should not be allowed to be modified.
// Doesn't really need the object, but takes one just to be consistent with `data_keys`.
function ro_keys (obj)
{
	return [ "id", ];
}

// Return a list of the keys in an object that _can_ be changed.  Essentially the
// opposite of `ro_keys`.  Does use the object in this case.
function data_keys (obj)
{
	var allkeys = l.keys(obj);
	var filter_keys = ro_keys(obj);
	filter_keys.push("");							// filter out any blank ones
	var dkeys = l.difference(allkeys, filter_keys);
	l.debug(4, "data_keys: doing set difference: [" + allkeys + "] - [" + filter_keys + "] == [" + dkeys + "]");
	return dkeys;
}

function rowIntoObject (row)
{
	l.debug(5, "rowIntoObject: firing up");
	var values = row.getValues()[0];
	var obj = {};
	for (var i=0, len=values.length; i < len; ++i)
	{
		l.debug(4, "rowIntoObject: calling dataHeaderColumn(" + (i + 1) + ")");
		var header = dataHeaderColumn(i + 1);
		if (header == undefined)
		{
			return;
		}
		obj[header] = values[i];
	}
	return obj;
}


function getID (range)
{
	var row = range.getRow();
	var tab = range.getSheet();
	var last_header_row = tab.getFrozenRows();
	if (row <= last_header_row)
	{
		l.showError("Get out of the header!");
		return;
	}

	var id_col = l.getColumnOfHeader(tab, "ID");
	if (id_col == undefined)
	{
		l.showError("You're not on a sheet with an ID column.");
		return;
	}
	var vals = tab.getSheetValues(row, id_col, 1, 1);
	l.debug(4, "getID: returning ID " + vals[0][0]);
	return vals[0][0];
}

function getRowForObject (id)
{
	var me = SpreadsheetApp.getActiveSpreadsheet();
	l.debug(3, "getRowForObject: id isa " + l.ref(id));
	var id_lookup = me.getRange("ItemIdLookup");
	id_lookup.getCell(1, 1).setValue(id);
	l.debug(4, "getRowForObject: looking up ID " + id_lookup.getCell(1, 1).getValue());
	var tab = me.getSheetByName( id_lookup.getCell(2, 1).getValue() );
	return tab == undefined ? undefined : l.getDataSlice(tab, { row: id_lookup.getCell(2, 2).getValue(), as: "range" });
}

function getObject (id)
{
	return rowIntoObject(getRowForObject(id));
}

var data_headers;
var data_header_row;
function dataHeaderColumn (column)
{
	if (data_headers == undefined)
	{
		var tab = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("RawData");
		Logger.log(`dataHeaderColumn: tab isa ${l.ref(tab)}`);
		// using `.slice()` to make a copy of the array, else we'd update the original array
		// oblig SO ref: https://stackoverflow.com/questions/7486085/copying-array-by-value-in-javascript
		data_header_row = l.tabHeaders(tab).slice();
		Logger.log(`dataHeaderColumn: row isa ${l.ref(data_header_row )}`);
		data_headers = {};
		for (var i=0, len=data_header_row.length; i < len; ++i)
		{
			var header = data_header_row[i].toLowerCase();
			data_header_row[i] = header;			// save LC version back to the array
			data_headers[header] = i + 1;			// go from 0-origin to 1-origin
		}
	}

	if (typeof(column) == 'number' && column > 0 && column <= data_header_row.length)
	{
		return data_header_row[column - 1];
	}
	else if (typeof(column) == 'string' && data_headers.hasOwnProperty(column))
	{
		return data_headers[column];
	}
	else
	{
		l.showError("No such column in data: " + column);
		return;
	}
}

function dataSet (row, column, value)
{
	if (!typeof(row) == "Range")
	{
		l.showError("dataSet: first arg must be a Range");
		return;
	}

	var col = dataHeaderColumn(column);
	if (col == undefined)
	{
		return;
	}
	else
	{
		row.getCell(1, col).setValue(value);
		return 1;
	}
}


function getIDofCurrentRow ()
{
	var pos = SpreadsheetApp.getActiveSpreadsheet().getActiveCell();
	var id = getID(pos);
	if (id == undefined)
	{
		l.showError("This row does not appear to be an item.");
		return;
	}
	return id;
}

function getCurrentRow ()
{
	var id = getIDofCurrentRow();
	if (id == undefined)
	{
		return;
	}
	return getRowForObject(id);
}


function newItem (object, tabname)
{
	// Handle defaults, since GAS JS is too old to do it in the signature.
	if ( tabname == undefined )
	{
		tabname = "RawData";
	}
	var tab = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("RawData");
	var new_row = l.getFirstEmptyRow(tabname, "Description");
	if (new_row == undefined)
	{
		l.showError("can't find an empty row for a new item");
		return;
	}
	if (!object.hasOwnProperty("description"))
	{
		l.showError("can't make an item without a description");
		return;
	}

	l.keys(object).forEach(function (key)
	{
		l.debug(2, "newItem: going to set " + key + " to " + object[key]);
		if (dataSet(new_row, key, object[key]) == undefined)
		{
			return;
		}
	});

	return new_row;
}

function updateItem (object)
{
	if (!object.hasOwnProperty("id"))
	{
		l.showError("Can't update item without ID.");
		return;
	}

	var row = getRowForObject(object.id);
	if (row == undefined)
	{
		l.showError("Illegal ID " + id + " (which should be impossible).");
		return;
	}
	var data = row.getSheet();
	// Probably should calculate the first and last column names somehow, but let's just call this a
	// performance enhancement, shall we?
	var first_col = l.getColumnOfHeader(data, "Priority");
	var last_col  = l.getColumnOfHeader(data, "Notes");
	// For `first_col`, have to subract 1 to convert 1-origin columns to 0-origin indices.
	// For `last_col`, the second arg to `slice` means "up to but not including" the indicated
	// element, so it's really `last_col - 1 + 1`.
	var data_to_update = row.getValues()[0].slice( first_col - 1, last_col );

	// NOTE! This loop assumes that `data_keys` will always return keys in the same order they exist
	// in the RawData tab.  Be careful mucking about with that function, or you'll break this one.
	l.foreach(data_keys(object), function (key, idx)
	{
		data_to_update[ dataHeaderColumn(key) - first_col ] = object[key];
	});
	l.debug(4, "updateItem: possibly updated data is: " + data_to_update.join(",")
			+ " (length " + data_to_update.length + ")");

	// Ranges are always two-dimensional, even when they're one-dimensional.  Therefore, we have to
	// put our array inside another array for `setValues`'s sake.
	data.getRange(row.getRow(), first_col, 1, last_col - first_col + 1).setValues( [data_to_update] );
}

function copyItem (obj)
{
	// The `obj` passed in should be a copy which it's okay to modify.
	l.foreach(ro_keys(), function (_) { delete obj[_] });				// don't mess with ro keys
	obj.added = l.today();												// we're adding it right now
	return newItem(obj);												// turn obj values into real item
}

function duplicateItem ()
{
	splitItem(false);
}
function splitItem (close_out)
{
	var id = getIDofCurrentRow();
	if (id == undefined)
	{
		return;
	}

	var obj = getObject(id);
	l.debug(2, "splitItem: object with keys: " + l.keys(obj).join(","));
	// If the user didn't demand one way or the other, figure out if this item
	// needs to be closed out.  Obviously we have to do this _before_ we blank
	// out the completed date for the new copy.  If it already has a completed
	// date, don't close it out.
	if (close_out == undefined)
	{
		close_out = obj.completed ? false : true;
	}
	// We'll use this object (which is just a copy of the values) to create a
	// new object, with *most* of the same values.
	delete obj.completed;		// this may be blank already, but certainly _should_ be
	delete obj.notes;			// notes don't carry over to new items
	var row = copyItem(obj);
	if (row == undefined)
	{
		return;
	}
	// close out the existing object if necessary
	if (close_out)
	{
		// Either the priority was already nothing, in which case this won't
		// change it, or it was something, in which case calling `completeItem`
		// would have cleared it.  Calling `completeItem` would also do a lot
		// of extra work in case there were no other items with the same
		// priority ... but, in this case, we *know* there's at least one other
		// such item, because we just created it.  So we're shortcutting a bit.
		updateItem({ id: id, priority: "", completed: l.today() });
	}
	// finally, let the user edit the new item if they want to
	row.activate();
}

function jumpToItem ()
{
	var id = getIDofCurrentRow();
	if (id == undefined)
	{
		return;
	}

	var row = getRowForObject(id);
	if (row == undefined)
	{
		return;
	}

	row.activate();
}

function visitFilteredRows (tabName, apply)
{
	var tab = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(tabName);
	var data_vals = tab.getDataRange().getValues();
	var cols = {};
	l.foreach(l.tabHeaders(tab), function (_, idx)
	{
		var col = _.toLowerCase();
		cols[col] = idx;
		l.debug(4, "visitFilteredRows: set col[" + col + "] to " + idx);
	});
	for (var i=0; i < data_vals.length; ++i)
	{
		var id = data_vals[i][cols.id];
		if (id == "")
		{
			break;
		}
		if (!apply(data_vals[i], cols))
		{
			// returning false from the apply() func means they want to bail out
			return false;
		}
	}
	return true;
}


function completeItem (obj)
{
	l.debug(5, "completeItem: firing up");

	if (obj.list == "Project")						// projects never close
	{
		l.showError("Projects are never completed (by definition).");
		return;
	}
	else if (obj.list == "Job")						// jobs can only close if all their tasks are completed
	{
		l.progress("Looking for outstanding tasks for job " + obj.code);
		// if visitFilteredRows makes it without bailing out early, that means there's no further tasks for this job
		var no_more_tasks = visitFilteredRows("JobItems", function (row, cols)
		{
			var code = row[cols.code];
			if (code == obj.code)
			{
				return false;
			}
			return true;
		});
		l.progress("Done");
		if (!no_more_tasks)
		{
			l.showError("Job cannot be completed (tasks are still outstanding!).");
			return;
		}
	}
	// job tasks or project blocks with a set priority need special handling:
	// we have to find any lower-priority tasks/blocks in the same job/project and bump their priorities
	else if ( obj.priority != "" )
	{
		var code = obj.job;
		if (code == undefined)
		{
			code = obj.project;
		}
		if (code == undefined)
		{
			return true;
		}

		l.progress("Popping priority stack (if necessary) for " + obj.code);
		var comptab = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("CompletedStackItem");
		var control = l.getDataSlice(comptab , { row: 1, as: 'range' });
		l.debug(4, "completeItem: control isa " + l.ref(control) + ", control values isa " + l.ref(control.getValues()));
		var rows_at, code_at, id_at, newpri_at;
		l.foreach(l.flatten(control.getValues()), function (_, idx)
		{
			var col = idx + 1;											// indices are 0-based, cols are 1-based
			l.debug(4, "completeItem: control cell at " + idx + " isa " + l.ref(_) + " is " + _);
			switch (_)
			{
				case "rows":
					l.debug(5, "completeItem: setting location of num rows");
					rows_at = col - 1;
					break;
				case "Code:":
					l.debug(5, "completeItem: setting column for code");
					code_at = col + 1;
					control.getCell(1, code_at).setValue(code);
					break;
				case "Completed Task:":
					l.debug(5, "completeItem: setting column for ID");
					id_at = col + 1;
					control.getCell(1, id_at).setValue(obj.id);
					break;
				case "New Pri:":
					l.debug(5, "completeItem: setting column for new priority");
					newpri_at = col + 1;
					break;
			}
		});
		if (rows_at == undefined || newpri_at == undefined)
		{
			l.showError("Can't figure out where number of items and/or new priority is.");
			return;
		}
		var rows = control.getCell(1, rows_at).getValue();
		if (rows < 1)
		{
			l.showError("No items to adjust!");
			return;
		}
		var newpri = control.getCell(1, newpri_at).getValue();

		var changed_col   = l.getColumnOfHeader(comptab, "Changed");
		var priority_col  = l.getColumnOfHeader(comptab, "Priority");
		var completed_col = l.getColumnOfHeader(comptab, "Completed");
		var ids           =      l.getDataSlice(comptab, { col: 1,             after_headers: true, as: 'values' });
		var changed       =      l.getDataSlice(comptab, { col: changed_col,   after_headers: true, as: 'values' });
		var priorities    =      l.getDataSlice(comptab, { col: priority_col,  after_headers: true, as: 'values' });
		var completeds    =      l.getDataSlice(comptab, { col: completed_col, after_headers: true, as: 'values' });
		l.progress("Updating " + rows + " items");
		var col = new Object();
		var first_row = comptab.getFrozenRows() + 1;
		l.foreach(ids, function (_, idx)
		{
			var id = _[0];
			var update = changed[idx][0];
			l.debug(4, "completeItem: for ID " + id + " changed is " + update + " (and isa " + l.ref(update) + ")");
			if (update)
			{
				var obj = getObject(id);
				var new_pri   = priorities[idx][0]
				var new_compl = completeds[idx][0]
				l.progress("Updating " + id + ": " + obj.priority + " => " + new_pri);
				obj.priority = new_pri;
				obj.completed = new_compl;
				updateItem(obj);
			}
		});

		l.debug(4, "going to clear 1," + id_at + " and 1," + code_at);
		control.getCell(1, id_at).clearContent();
		control.getCell(1, code_at).clearContent();
		l.progress("Done");
		obj.priority = newpri;
	}
	return true;
}

function markCompleted ()
{
	l.debug(5, "markCompleted: firing up");
	var id = getIDofCurrentRow();
	l.debug(3, "markCompleted: got ID [" + id + "]");
	if (id == undefined)
	{
		return;
	}

	var obj = getObject(id);
	if (completeItem(obj) == undefined)
	{
		l.showError("Cannot mark item completed.");
	}
	else
	{
		obj.completed = l.today();
		updateItem(obj);
	}
}

function markCompletedAsOfYesterday ()
{
	l.debug(5, "markCompletedAsOfYesterday: firing up");

	var id = getIDofCurrentRow();
	if (id == undefined)
	{
		return;
	}

	var obj = getObject(id);
	completeItem(obj);
	obj.completed = l.dateAsString( l.addDays(l.today({ as: 'date' }), -1) );
	updateItem(obj);
}

function markCompletedWithNote ()
{
	var id = getIDofCurrentRow();
	if (id == undefined)
	{
		return;
	}
	var note = l.prompt("MARK COMPLETED", "Completion note:");
	if (note == undefined)
	{
		return;
	}

	var obj = getObject(id);
	completeItem(obj);
	obj.notes = note;
	obj.completed = l.today();
	updateItem(obj);
}

function markCancelled ()
{
	var id = getIDofCurrentRow();
	if (id == undefined)
	{
		return;
	}
	var reason = l.prompt("CANCEL ITEM", "Reason for cancellation:");
	if (reason == undefined)
	{
		return;
	}

	var obj = getObject(id);
	completeItem(obj);
	obj.notes = reason;
	obj.list = 'Cancelled';
	obj.completed = l.today();
	updateItem(obj);
}

function setDueDate (new_val)
{
	var item = getCurrentRow();
	if (item == undefined)
	{
		return;
	}

	var due_col = dataHeaderColumn("due");
	var cell = item.getCell(1, due_col);
	l.debug(4, "setDueDate: incoming value has type " + l.ref(new_val));
	if ( l.ref(new_val) == "Date" )
	{
		l.dateIntoCell(new_val, cell);
	}
	else
	{
		cell.setValue( new_val );
	}
}

function incPriority (base, inc, opts)
{
	// Handle defaults, since GAS JS is too old to do it in the signature.
	if ( opts == undefined )
	{
		opts = { max_num: undefined, max_letter: undefined };
	}
	if ( opts.max_num == undefined )
	{
		opts.max_num = 3;
	}
	if ( opts.max_letter == undefined )
	{
		opts.max_letter = 26;
	}

	var letter = base.charCodeAt(0) - 64;	// so "A" == 1, "B == 2, "C" == 3, etc
	var number = base.charAt(1);
	number = Number(number) + inc;
	if (number < 1 || number > opts.max_num)
	{
		// subtract 1 to go back to 0-index
		number -= 1;
		// divide by 3 because this is essentially base-3
		// then floor (not truncate!) to get the proper integer
		var letter_adjustment = Math.floor( number / opts.max_num );
		letter += letter_adjustment;
		// number is now the remainder
		// see: http://javascript.about.com/od/problemsolving/a/modulobug.htm
		// have I mentioned lately that Javascript is stupid?
		number = (number % opts.max_num + opts.max_num) % opts.max_num;
		// and, finally, back to 1-index
		number += 1;
		if (letter < 1 || letter > opts.max_letter)
		{
			l.showError("trying to adjust priority out-of-bounds: " +
					letter + '/' + number + ' [' + opts.max_letter + '/' + opts.max_num + ']');
			return;
		}
	}
	return String.fromCharCode(64 + letter) + number;
}

function tweakPriority (amount)
{
	var item;
	var me = SpreadsheetApp.getActiveSpreadsheet();
	var selection = me.getActiveRange();
	selHeight = selection.getHeight();
	if (selHeight > 1)
	{
		for (var i=selHeight; i >= 1; --i)
		{
			var id = getID(selection.getCell(i,1));
			if (id != undefined)
			{
				item = getRowForObject(id);
				if (item != undefined)
				{
					tweakPriorityOfItem(item, amount);
				}
			}
		}
	}
	else
	{
		item = getCurrentRow();
		if (item != undefined)
		{
			tweakPriorityOfItem(item, amount);
		}
	}
}

function tweakPriorityOfItem (item, amount)
{
	var due_col = dataHeaderColumn("due");
	var cell = item.getCell(1, due_col);
	var value = cell.getValue();
	if (value != "")
	{
		var date = l.dateFromCell(cell);
		l.debug(3, "tweakPriority: got date from cell: " + date.toString());
		l.dateIntoCell(l.addDays(date, amount), cell);
	}
	else
	{
		var pri_col = dataHeaderColumn("priority");
		cell = item.getCell(1, pri_col);
		value = cell.getValue();
		if (value != "")
		{
			var new_pri = incPriority(value, amount);
			if (new_pri == undefined)
			{
				// error already printed by incPriority
				return;
			}
			l.debug(3, "tweakPriority: setting (hopefully) to new priority: " + new_pri);
			cell.setValue(new_pri);
		}
		else
		{
			if (l.confirm("No priority or due date; shall we push from today's date?"))
			{
				var date = l.today({ as: 'date' });
				date.setDate(date.getDate() + amount);
				cell = item.getCell(1, due_col);
				l.dateIntoCell(date, cell);
			}
			else
			{
				l.showError("Don't know how to push/bump (item has no due date or priority).");
				return;
			}
		}
	}
}

function bumpItem () { tweakPriority(-1) }
function pushItem () { tweakPriority(1)  }

function pushItemArbitrary ()
{
	var push_amt = l.prompt("PUSH ITEM", "Push by (days) or push to (date):");
	if (push_amt == undefined)
	{
		return;
	}

	// check to see whether it's a date or an offset
	push_amt = push_amt.toLowerCase();
	if ( new RegExp('/').test(push_amt) )			// prolly nicer-looking than `/\//.test` ...
	{
		setDueDate(push_amt);
	}
	else if ( /^[+-]?\d+$/.test(push_amt) )
	{
		tweakPriority(Number(push_amt));
	}
	else if ( /^[a-z]+$/.test(push_amt) )
	{
		var days = { sun: 0, mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6 };
		var day = days[push_amt];
		if (day == undefined)
		{
			l.showError("I thought " + push_amt + " was a day name, but I don't recognize it.");
			return;
		}

		var date = l.today({ as: 'date' });
		date.setDate( date.getDate() + ((day + 7 - date.getDay()) % 7) );
		date = l.nextDoW(date, day);
		l.debug(3, "pushItemArbitrary: new date => " + date.toISOString());
		setDueDate(date);
	}
	else
	{
		l.showError("Don't know how to convert " + push_amt + " to a date or date offset.");
		return;
	}
}


/*
 ************************
 *	InTray & Recurring	*
 ************************
 */

function newInTray ()
{
	var descr = l.prompt("NEW ITEM", "Item to add to in tray:");
	if (descr == undefined)
	{
		return;
	}
	newItem({ list: "InTray", added: l.today(), description: descr });
}

function newAndEdit ()
{
	var descr = l.prompt("NEW ITEM", "Item to add:");
	if (descr == undefined)
	{
		return;
	}
	var row = newItem({ list: "InTray", added: l.today(), description: descr });
	row.activate();
}

function emptyInTray ()
{
	var tab = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("InTray");
	var first_row = tab.getFrozenRows() + 1;
	var last_row = l.getFirstEmptyRow("InTray", "Description").getRow() - 1;
	if (first_row > last_row)
	{
		l.showError("InTray is already empty!");
		return;
	}

	l.debug(2, "emptyInTray: going from row " + last_row + " to row " + first_row);
	for (var i=last_row; i >= first_row; --i)
	{
		var row = l.getDataSlice(tab, { row: i, as: 'range' });
		var new_list = row.getValue();				// value of the first cell in the row
		var id = getID(row);
		updateItem({ id: id, list: new_list });
		row.getCell(1, 1).clear();					// clear out the new_list value now that we've used it
	}
}


function addRecurring ()
{
	var me = SpreadsheetApp.getActiveSpreadsheet();
	var to_add = me.getSheetByName("RecurringToAdd");
	// to_add.activate();

	var num_items = to_add.getRange("B6").getValue();
	var num_jobs  = to_add.getRange("B16").getValue();
	if (num_items == 0)
	{
		l.showError("No recurring tasks marked.");
		return;
	}
	else
	{
		if (!l.confirm("Going to add " + num_items + " tasks and " + num_jobs + " jobs; proceed?"))
		{
			return;
		}
	}

	var copyRanges =
	[
		{ howMany:num_items, rangeFrom: 9, copyTo:"RawData", startAt:"Priority" },
		{ howMany:num_jobs,  rangeFrom:19, copyTo:"RawJobs", startAt:"Code"     },
	];
	l.foreach(copyRanges, function (_)
	{
		if (_.howMany > 0)
		{
			l.debug(4, "addRecurring: parsing " + l.keys(_));
			var start_row = to_add.getRange(_.rangeFrom + 0, 3).getValue();
			var start_col = to_add.getRange(_.rangeFrom + 1, 3).getValue();
			var num_rows  = to_add.getRange(_.rangeFrom + 2, 3).getValue();
			var num_cols  = to_add.getRange(_.rangeFrom + 3, 3).getValue();
			l.debug(4, "addRecurring: parsed: " + start_row + "/" + start_col + ", " + num_rows + "x" + num_cols);
			var toCopy    = to_add.getRange(start_row, start_col, num_rows, num_cols);
			l.debug(2, "addRecurring: copying " + toCopy.getHeight() + " rows and " + toCopy.getWidth() + " columns");

			l.debug(2, "addRecurring: copying to tab " + _.copyTo + " starting at " + _.startAt);
			var data = me.getSheetByName(_.copyTo);
			var dest_row = jumpToBottom(_.copyTo).getRow();
			var first_data_col = l.getColumnOfHeader(data, _.startAt);
			toCopy.copyValuesToRange(data, first_data_col, first_data_col + num_cols - 1, dest_row, dest_row + num_rows - 1);
		}
	});

	// tweak index of alternating tasks
	var recur       = me.getSheetByName("Recurring");
	var descr_col   = l.getColumnOfHeader(recur, "Description");
	var altern_col  = l.getColumnOfHeader(recur, "alternations");
	var altern_list = l.getDataSlice(recur, { col: altern_col, after_headers: true, as: 'values' });
	l.each(altern_list, function (value)
	{
		value = value[0];
		if (value)
		{
			var cell = recur.getRange(value, descr_col);
			var parts = cell.getValue().split('//');
			var which = l.int( parts.pop() );
			// update the source so next time we get the next alternation
			var next = which == parts.length ? 1 : which + 1;
			parts.push( next );
			cell.setValue( parts.join('//') );
		}
	});

	// clear stuff on Recurring tab before reporting success
	// that way, timing out won't leave stray Xs lying around
	l.getDataSlice(recur, { col: 1, after_headers: true, as: 'range' }).clearContent();
	l.getDataSlice(recur, { col: 2, after_headers: true, as: 'range' }).clearContent();
	l.getDataSlice(recur, { col: 3, after_headers: true, as: 'range' }).clearContent();

	l.infoMsg("Added " + num_items + " new tasks.");
}


function newTVSeason ()
{
	var me = SpreadsheetApp.getActiveSpreadsheet();
	var tab = me.getSheetByName("TVRawData");

	var show = l.prompt("NEW TV SHOW", "Show to add:");
	if (show == undefined)
	{
		return;
	}
	var network = l.prompt("NEW TV SHOW", "Network (required):");
	var code;
	if (network == undefined)
	{
		return;
	}
	else
	{
		var code_table = me.getRange("TVCodeLookup").getValues();
		l.debug(3, "newTVSeason: code_table isa " + l.ref(code_table));
		l.debug(3, "newTVSeason: read " + code_table.length + " rows");
		var row =
			l.grep(code_table, function (row)
			{
				l.debug(4, "newTVSeason: checking row [" + row[0] + "][" + row[1] + "]");
				return row[0] == network;
			});
		if (row == undefined)
		{
			l.showError("Network " + network + " not recognized (check TV code on ControlData tab).");
			return;
		}
		code = row[1];
		l.debug(2, "newTVSeason: got code " + code);
	}
	var context = l.prompt("NEW TV SHOW", "Watching with (required):");
	if (context == undefined)
	{
		return;
	}
	var season = l.int(l.prompt("NEW TV SHOW", "Season # (required):"));
	if (season == undefined)
	{
		return;
	}
	var num_episodes = l.int(l.prompt("NEW TV SHOW", "# episodes this season (required):"));
	if (num_episodes == undefined)
	{
		return;
	}
	var start = l.int(l.prompt("NEW TV SHOW", "Start with episode? (default: 1)"));
	if (start == undefined)
	{
		start = 1;
	}
	if (start > num_episodes)
	{
		l.showError("Start episode must be smaller than number of episodes.");
		return;
	}

	var descr = show + " [S" + season + "]";
	var obj = { list: "Season", context: context, added: l.today(), code: code, description: descr };
	newItem(obj, "TVRawData");
	var pri = "A1";
	for (var i=start; i <= num_episodes; ++i)
	{
		if (i < 0)
		{
			descr = show + " [S" + (season - 1) + "E" + (num_episodes + i + 1) + "]";
		}
		else if (i > 0)
		{
			descr = show + " [S" + season + "E" + i + "]";
		}
		else
		{
			descr = undefined;
		}
		if (descr != undefined)
		{
			obj = { priority: pri, list: "Show", context: context, added: l.today(), code: code, description: descr };
			newItem(obj, "TVRawData");
			pri = incPriority(pri, 1, { max_num: 9 });
		}
	}
}


/*
 ********************
 *		Tasks		*
 ********************
 */

function newTaskToday (mark_completed)
{
	// Handle defaults, since GAS JS is too old to do it in the signature.
	if ( mark_completed == undefined )
	{
		mark_completed = false;
	}

	var descr = l.prompt("NEW TASK", "Task to add:");
	if (descr == undefined)
	{
		return;
	}
	var context = l.prompt("NEW TASK", "Context (required):");
	if (context == undefined)
	{
		return;
	}

	var obj = { list: "Task", context: context, added: l.today(), description: descr };
	if (mark_completed)
	{
		obj.completed = l.today();
	}
	else
	{
		obj.due = l.today();
	}

	var code = l.prompt("NEW TASK", "Code (optional):");
	if (code != undefined)
	{
		if (code.length == 3)
		{
			obj.project = code;
		}
		else
		{
			obj.job = code;
		}
	}

	newItem(obj);
}

function newTaskCompleted () { newTaskToday(true) }

function newWorkTask ()
{
	var descr = l.prompt("NEW TASK", "Task to add:");
	if (descr == undefined)
	{
		return;
	}
	var code = l.prompt("NEW TASK", "Code (required):");
	if (code == undefined)
	{
		return;
	}
	else
	{
		// Verify this is a work code.
		if (code.length == 5 || code.length == 3 && code.charAt(0) == 'W')
		{
			// all good
		}
		else
		{
			l.showError("Code " + code + " does not appear to be a work code.");
			return;
		}
	}
	var priority = l.prompt("NEW TASK", "Priority (default: A1):");
	if (priority == undefined || priority == "")
	{
		priority = 'A1';
	}
	var obj = { list: "Task", context: "Work", added: l.today(), code: code, priority: priority, description: descr };
	newItem(obj);
}


/*
 ********************
 *		Daily		*
 ********************
 */

function newDay ()
{
	l.debug(5, "newDay: firing up");
	var me = SpreadsheetApp.getActiveSpreadsheet();
	var tab = me.getSheetByName("Today");
	tab.activate();
	l.debug(5, "newDay: activated tab");

	// save any potential changes to "yesterday"
	// before we switch over to "tomorrow"
	saveDayEnd();

	var date = me.getRange("TodaysDate");
	date.setValue( l.today() );

	l.debug(5, "newDay: going to pull template tab");
	var templ = me.getSheetByName("DayTemplates");
	l.debug(5, "newDay: going to find 'Today' header");
	var col = l.getColumnOfHeader(templ, "Today");
	l.debug(5, "newDay: pulling new schedule");
	var values_first  = l.getDataSlice(templ, { col: col,     as: 'values' });
	var values_second = l.getDataSlice(templ, { col: col + 1, as: 'values' });
	var sched_first   = tab.getRange("ScheduleFirstHalf");
	var sched_second  = tab.getRange("ScheduleSecondHalf");
	l.debug(5, "newDay: finding old schedule");
	// cut schedule down to however many values we got back from the template
	sched_first = sched_first.offset(0, 0, values_first.length);
	sched_first.setValues(values_first);
	sched_second = sched_second.offset(0, 0, values_second.length);
	sched_second.setValues(values_second);

	// now that "tomorrow" is "today," save again
	saveDay();

	// leave the user in a place to update the day start
	tab.getRange("InputDayStart").activate();
}


// get the CalenDiary sheet and return it as an object
function _get_diary ()
{
	// using hardcoded ID for diary sheet open
	// less than ideal, but a PITA to do it any other way
	return SpreadsheetApp.openById("1F9ge-m3ez4Yp4jzuQvtRolTP61Dr1rH7D2qoibRxkzI");
}

function saveDay ()
{
	l.debug(5, "saveDay: firing up");
	var me = SpreadsheetApp.getActiveSpreadsheet();
	var tab = me.getSheetByName("DiaryData");
	var date = me.getRange("TodaysDateSortable").getValue();

	l.debug(5, "saveDay: about to open diary");
	var diary = _get_diary();
	var day = diary.getSheetByName(date);
	l.debug(2, "saveDay: trying to find sheet: " + date);
	if (day == null)
	{
		// create tab in diary sheet
		l.debug(5, "saveDay: making new tab");
		var template = diary.getSheetByName("Template");
		day = tab.copyTo(diary);
		day.setName(date);
		l.debug(5, "saveDay: created new tab");
	}
	else
	{
		if (!l.confirm("Will overwrite existing data!"))
		{
			return false;
		}
	}

	l.debug(5, "saveDay: going to copy values");
	var values = tab.getDataRange();
	var rows = values.getNumRows();
	var cols = values.getNumColumns();
	if (day.getMaxColumns() < cols || day.getMaxRows() < rows)
	{
		l.showError(`Calendiary tab ${date} is too small; embiggen template tab?`);
		return false;
	}
	day.getRange(1, 1, rows, cols).setValues(values.getValues());
	l.debug(5, "saveDay: copied values");

	l.debug(5, "saveDay: done");
	return true;
}

function saveDayEnd ()
{
	l.debug(5, "saveDayEnd: firing up");
	var me = SpreadsheetApp.getActiveSpreadsheet();
	var tab = me.getSheetByName("DiaryData");
	var date = me.getRange("TodaysDateSortable").getValue();

	l.debug(5, "saveDay: about to open diary");
	var diary = _get_diary();
	var day = diary.getSheetByName(date);
	l.debug(2, "saveDay: trying to find sheet: " + date);
	if (day == null)
	{
		// no tab means that the day _start_ hasn't been copied yet
		// so we can't copy the day end
		l.showError(`Cannot locate ${date} tab; try saving whole day first.`);
		return false;
	}

	// find the End of Day marker and grab the data
	l.debug(5, "saveDayEnd: picking out end data");
	var last_col = tab.getLastColumn();									l.debug(4, `saveDayEnd: last_col = ${last_col}`);
	var top_row  = tab.getRange(1, 1, 1, tab.getMaxColumns());
	var end_col  = top_row.getValues()[0].indexOf("End of Day") + 1;	l.debug(4, `saveDayEnd: end_col = ${end_col}`);
	var sch_rows = me.getRange("ScheduleFirstHalf").getNumRows();		// assume both halves are the same size
	var num_rows = sch_rows + tab.getFrozenRows();						// don't forget to allow for the header!
	var num_cols = last_col - end_col + 1;
	l.debug(3, `saveDayEnd: End of Day data found at 1:${end_col} to ${num_rows}:${last_col}`);
	var end_data = tab.getRange(1, end_col, num_rows, num_cols);

	// end_col _should_ be the same on the diary tab, but don't assume
	end_col  = day.getRange(1, 1, 1, tab.getMaxColumns()).getValues()[0].indexOf("End of Day") + 1;
	if (day.getMaxColumns() < end_col + num_cols || day.getMaxRows() < num_rows)
	{
		l.showError(`Calendiary tab ${date} is too small; embiggen template tab?`);
		return false;
	}
	l.debug(3, `saveDayEnd: saving data to ${date}! 1:${end_col} to ${num_rows}:${last_col}`);
	day.getRange(1, end_col, num_rows, num_cols).setValues(end_data.getValues());

	l.debug(5, "saveDayEnd: done");
}


function saveToHistory ()
{
	l.debug(5, "saveToHistory: firing up");
	var diary = SpreadsheetApp.openById("1F9ge-m3ez4Yp4jzuQvtRolTP61Dr1rH7D2qoibRxkzI");
	l.progress("Finding earliest month");
	var tabs = diary.getSheets();

	var quarters   = new Object();
	var month_tabs = new Object();
	for (var i = 0; i < tabs.length; ++i)
	{
		var name = tabs[i].getName();
		if ( /\d\d\d\d-\d\d-\d\d/.test(name) )
		{
			var year  = name.substr(0,4);
			var month = name.substr(5,2);
			var quarter = l.int((month - 1) / 3) + 1;
			var sheet_name = "CalenDiary History " + year + "-Q" + quarter;
			if (month_tabs[month] == undefined)
			{
				month_tabs[month] = [];
			}
			month_tabs[month].push(tabs[i]);
			if (quarters[sheet_name] == undefined || month < quarters[sheet_name])
			{
				quarters[sheet_name] = month;
			}
		}
	}
	l.progress("Finding history sheet name");
	var potentials = l.keys(quarters);
	potentials.sort();
	var history_name = potentials[0];
	var history_files = DriveApp.getFilesByName(history_name);
	if (history_files.hasNext())
	{
		var history = SpreadsheetApp.open(history_files.next());
		var tabs_to_save = month_tabs[quarters[history_name]];
		var tab_names = tabs_to_save.map(function (_) { return _.getName() }).toString();
		if (l.confirm("Will save these tabs to " + history_name + ": " + tab_names))
		{
			for (var i = 0; i < tabs_to_save.length; ++i)
			{
				var day = tabs_to_save[i];
				var day_name = day.getName();
				l.progress("Moving tab: " + day_name);
				var new_tab = day.copyTo(history);
				new_tab.setName(day_name);
				diary.deleteSheet(day);
			}
		}
		else
		{
			l.showError("Bailing out at user request.");
		}
	}
	else
	{
		l.showError("You must create sheet: " + history_name);
	}
	l.progress("Done");
}


/*
 ********************
 *		Projects	*
 ********************
 */


/*
 ************************
 *		multiple tabs	*
 ************************
 */

function showIDofCurrentRow ()
{
	var id = getIDofCurrentRow();
	if (id != undefined)
	{
		var ui = SpreadsheetApp.getUi();
		ui.alert("INFO", "ID of current row: " + id, ui.ButtonSet.OK);
	}
}


function resort ()
{
	var tab = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
	var data = tab.getDataRange().getValues();
	var to_delete = [];
	for (var i = data.length - 1; i >= 0; --i)
	{
		if (data[i][0] == "X")
		{
			var row = i + 1;
			l.debug(4, "resort: going to delete row " + row);
			to_delete.push(row);
		}
	}
	for (var i = 0; i < to_delete.length; ++i)
	{
		var row = to_delete[i];
		l.debug(4, "resort: about to delete row " + row);
		tab.deleteRow(row);
	}
	tab.sort(1);
	tab.getRange(tab.getFrozenRows()+1, tab.getFrozenColumns()+1).activate();
}


function jumpToBottom (tabname)
{
	if (tabname == undefined)
	{
		var me = SpreadsheetApp.getActiveSpreadsheet();
		var tab = me.getActiveSheet();
		tabname = tab.getName();
	}

	var row;
	if (tabname == "RawData" || tabname == "TVRawData")
	{
		row = l.getFirstEmptyRow(tabname, "Description");
	}
	else
	{
		row = l.getFirstEmptyRow(tabname);
	}
	if (row == undefined)
	{
		l.showError("No blank rows!");
		return;
	}
	return row.activate();
}


/*
 ************************
 *		sheet setup		*
 ************************
 */

function onOpen ()
{
	var ui = SpreadsheetApp.getUi();
	ui.createMenu("Todo")
		.addItem("New Task for Today", "newTaskToday")
		.addItem("New Work Task", "newWorkTask")
		.addItem("New Item and Jump to Edit", "newAndEdit")
		.addItem("Add Recurring Tasks", "addRecurring")
		.addSubMenu(ui.createMenu("More New Stuff")
				.addItem("New InTray Item", "newInTray")
				.addItem("Record Completed Task", "newTaskCompleted")
				.addItem("New TV Season", "newTVSeason")
				.addItem("Duplicate Item", "duplicateItem")
			)
		.addSeparator()
		.addItem("Jump to Full Edit", "jumpToItem")
		.addItem("Push Item (1 Day)", "pushItem")
		.addItem("Mark Completed", "markCompleted")
		.addSubMenu(ui.createMenu("More Edits")
				.addItem("Bump Item", "bumpItem")
				.addItem("Push Item (Any Amount)", "pushItemArbitrary")
				.addSeparator()
				.addItem("Mark Completed (with Note)", "markCompletedWithNote")
				.addItem("Mark Completed as of Yesterday", "markCompletedAsOfYesterday")
				.addItem("Split Open Item", "splitItem")
				.addItem("Cancel Item", "markCancelled")
			)
		.addSeparator()
		.addItem("Empty InTray", "emptyInTray")
		.addItem("Start a New Day", "newDay")
		.addSubMenu(ui.createMenu("More Transitions")
				.addItem("(Re)Save Day to Diary", "saveDay")
				.addItem("Resave End of Day to Diary", "saveDayEnd")
				.addItem("Save CalenDiary's Earliest Month to History", "saveToHistory")
			)
		.addSeparator()
		.addSubMenu(ui.createMenu("More Utility Items")
				.addItem("Show Item ID", "showIDofCurrentRow")
				.addItem("Resort", "resort")
			)
		.addItem("Find Blank Row", "jumpToBottom")
		.addSeparator()
		.addSubMenu(ui.createMenu("Developer Functions")
				.addItem("Debug Tab", "l.debug_tab")
				.addItem("Clear Tab Headers Cache", "l.tabHeadersClearCache")
				.addItem("Test", "testCurrentThing")
			)
		.addToUi();
}

function testCurrentThing ()
{
	var me = SpreadsheetApp.getActiveSpreadsheet();
	var tab = me.getActiveSheet();
}
